# grokking_algorithms

## 第一章 简介

算法是一组完成任务的指令。

对数：对数运算是幂运算的逆运算。

### 1. 二分查找

二分查找可以简单理解为对半查找，先按照列表的一半的位置判断与期望数字进行比较，如果小的话舍弃右半部分并将中间数值当成最大的数，然后继续进行下一次查找，如果大的话舍弃左半部分并将中间数值当成最小的数，然后继续下一次查找，如果查到最后一个数也不符合则返回`None`。至于代码中的中间值索引加一或者减一是因为之前判断过中间值是否与期望值相同，所以在这个条件不符合时，将这个中间值从下一次判断中排除掉，所以就需要减一加一。

注意：只有当这个查找的列表是有序列表时才管用，而且在运行时计算的只是索引位置并不会产生新的列表。

代码：

[二分查找代码](./s1/binary_search.py)

```python
def binary_search(list, item):
    low = 0
    high = len(list) - 1

    while low <= high:
        mid = (low + high) // 2
        guess = list[mid]
        if guess == item:
            return mid
        elif guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None
```

### 2. 运行时间



线性时间： 查找的次数与列表长度相同 表示方法：O(n)

对数时间：二分查找的运行时间为对数时间或者log时间 表示方法：O(log n)



大O表示方法：

- 大O表示法指出了算法有多快。
- 大O表示法让你能够比较操作数，它指出了算法运行时间的增速。
- n为操作数。
- 大O表示法指出了最糟情况下的运行时间。



常见的大O运行时间：

- O(log n)，对数时间，二分查找算法
- O(n)，线性时间，简单查找
- O(n*log n)，快速排序（一种速度较快的排序算法）
- O(n^2)，选择排序（一种速度较慢的排序算法）
- O(n!)，旅行商问题（一种非常慢的算法）



大O算法的启示：

- 算法的速度指的并非时间，而是操作数的增速
- 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加
- 算法的运行时间用大O表示法表示
- O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。















